/*
    SPDX-FileCopyrightText: 2017 The Android Open Source Project
    SPDX-FileCopyrightText: 2022 Fushan Wen <qydwhotmail@gmail.com>

    SPDX-License-Identifier: Apache-2.0
*/

#ifndef WALLPAPERCOLORS_H
#define WALLPAPERCOLORS_H

#include <map>
#include <optional>
#include <string>
#include <vector>

#include <QRgb>

#include "cam/colorappearancemodel.h"

/**
 * Provides information about the colors of a wallpaper.
 *
 * Exposes the 3 most visually representative colors of a wallpaper.
 */
class WallpaperColors
{
public:
    /**
     * Constructs a new object from a set of colors, where hints can be specified.
     *
     * @param colorToPopulation Map with keys of colors, and value representing the number of
     *                          occurrences of color in the wallpaper.
     * @param colorHints        A combination of color hints.
     */
    explicit WallpaperColors(const std::map<QRgb, unsigned> &colorToPopulation, const std::vector<QRgb> &palette, int colorHints);

    /**
     * Constructs @c WallpaperColors from a bitmap.
     *
     * Main colors will be extracted from the bitmap.
     *
     * @param pixels Source where to extract from.
     */
    static WallpaperColors fromBitmap(const std::vector<QRgb> &pixels);

    /**
     * Gets the most visually representative color of the wallpaper.
     * "Visually representative" means easily noticeable in the image,
     * probably happening at high frequency.
     *
     * @return A color.
     */
    QRgb getPrimaryColor() const;

    /**
     * Gets the second most preeminent color of the wallpaper. Can be null.
     *
     * @return A color, may be null.
     */
    std::optional<QRgb> getSecondaryColor() const;

    /**
     * Gets the third most preeminent color of the wallpaper. Can be null.
     *
     * @return A color, may be null.
     */
    std::optional<QRgb> getTertiaryColor() const;

    /**
     * List of most preeminent colors, sorted by importance.
     *
     * @return List of colors.
     * @hide
     */
    const std::vector<QRgb> &getMainColors() const;

    /**
     * Map of all colors. Key is rgb integer, value is importance of color.
     *
     * @return List of colors.
     */
    const std::map<QRgb, unsigned> &getAllColors() const;

    bool operator=(const WallpaperColors &other) const;

    /**
     * Returns the color hints for this instance.
     * @return The color hints.
     */
    int getColorHints() const;

    operator std::string() const;

    /**
     * Specifies that dark text is preferred over the current wallpaper for best presentation.
     *
     * eg. A launcher may set its text color to black if this flag is specified.
     */
    static constexpr int HINT_SUPPORTS_DARK_TEXT = 1 << 0;

    /**
     * Specifies that dark theme is preferred over the current wallpaper for best presentation.
     *
     * eg. A launcher may set its drawer color to black if this flag is specified.
     */
    static constexpr int HINT_SUPPORTS_DARK_THEME = 1 << 1;

    /**
     * Specifies that this object was generated by extracting colors from a bitmap.
     */
    static constexpr int HINT_FROM_BITMAP = 1 << 2;

private:
    static std::array<double, 360> getHueProportions(const std::map<QRgb, Cam> &colorToCam, const std::map<QRgb, unsigned> &colorToPopulation);
    static std::map<QRgb, double>
    getColorToHueProportion(const std::vector<QRgb> &colors, std::map<QRgb, Cam> &colorToCam, const std::array<double, 360> &hueProportions);
    static double getScore(const Cam &cam, double proportion);
    static int wrapDegrees(int degrees);

    /**
     * Checks if image is bright and clean enough to support light text.
     *
     * @param pixels What to read.
     * @param dimAmount How much wallpaper dim amount was applied.
     * @return Whether image supports dark text or not.
     */
    static int calculateDarkHints(const std::vector<QRgb> pixels);

    static constexpr bool DEBUG_DARK_PIXELS = false;

    // Maximum size that a bitmap can have to keep our calculations valid
    static constexpr int MAX_BITMAP_SIZE = 112;

    // Even though we have a maximum size, we'll mainly match bitmap sizes
    // using the area instead. This way our comparisons are aspect ratio independent.
    static constexpr int MAX_WALLPAPER_EXTRACTION_AREA = MAX_BITMAP_SIZE * MAX_BITMAP_SIZE;

    // When extracting the main colors, only consider colors
    // present in at least MIN_COLOR_OCCURRENCE of the image
    static constexpr double MIN_COLOR_OCCURRENCE = 0.05;

    // Decides when dark theme is optimal for this wallpaper
    static constexpr double DARK_THEME_MEAN_LUMINANCE = 0.3;

    // Minimum mean luminosity that an image needs to have to support dark text
    static constexpr double BRIGHT_IMAGE_MEAN_LUMINANCE = 0.7;

    // We also check if the image has dark pixels in it,
    // to avoid bright images with some dark spots.
    static constexpr double DARK_PIXEL_CONTRAST = 5.5;
    static constexpr double MAX_DARK_AREA = 0.05;

    std::vector<QRgb> m_mainColors;
    std::map<QRgb, unsigned> m_allColors;
    int m_colorHints = 0;
};

#endif // WALLPAPERCOLORS_H
